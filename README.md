# RoboTraits: Implicitly Secure Generic Interfaces for Deployment of Robotics Packages

Following on from LLM chats about extendability of Nixos-like methods to robotics software deployment, this project is about the concept of applying traits to packages and communication channels in an open source robotics framework, like ROS2.

## Overview

Inspired by the Nixos thesis paper, I have begun to think about how software deployment can be analogous to programming. Nix embodies the analogy of treating deploying software in a filesystem like memory management, at the level of C/C++ (where the compiler can make decisions about what type of data lives at a certain address, because it controls these things), as opposed to assembly. It also states that this is the current limit: doing more sophisticated 'memory management' on the filesystem like garbage collection is beyond what is offered in unix. 

Well, I want to do the same thing: come up with my own analogies to how secure robotics software deployment is like programming. Specifically, I would like to inherit the idea of _traits_ (from languages like C++ and Rust), and apply it to (a) software packages and (b) communication channels. The benefits for this are much the same as the benefits you get in programming contexts, as I will walk you through next.

First, it enables the high-level paradigm of _interfaces_, without incurring runtime cost or convolution via inheritance. If a component _implements_ a trait, we can make guarantees about how it can and cannot be used. The main benefit of traits, as I see, is that it essentially adds an abstract layer on top of normal functionality (e.g., a normal c++ class) that the compiler uses, but doesn't have any effect whatsoever on the actual runtime. Whereas, in the case of virtual polymorphic interfaces, this _abstract_ set of concerns ends up having big implications for the _concrete_, which is not ideal. Inheritance is also too heavy handed as a sole principal for managing re usability and abstraction: not everything that has common functionality should be thought of in terms of a 'is a' relationship with something else. 

In the case of secure robotics deployment, traits would enable the system to enforce what components _can_ go with which else, bringing a level of 'plug and play' that isn't quite already there. For instance, with ROS2, currently popular nodes and tooling expects a particular message 'type', but doesn't care any more about the semantic meaning of the data coming in. This opens the system up to brittleness: if a navigation toolbox node holds assumptions about the point cloud data it expects to receive (beyond the simple fact that it is point cloud data), then if it receives data that breaks these assumptions, it will cease to behave as intended. It is therefore left up to the author of the project properly documenting these decisions, and the consumer of the project diligently reading and understanding this documentation. It is akin to C: all _can_ work well as long as best practices are followed, but it breaks down when you have lots of different users interacting with it, who have different experience levels and use cases. So, in short, traits will enable users and systems to reason about the _objectives_ of the various software components, and the real _compatibility_ of data channels and message types - for example, if a channel implements the _trait_ 'camera_feed', it must have 3-channel RGB data and have an interface for getting it, while the actual message type can be completely arbitrary (this builds upon ROS's composable message types by enabling a whole new level of customisability, expressivity, and ease-of-integration, as devs don't have to choose between supporting built-in types and tuning the message type for their business needs). This can be extended for all domain-specific tasks robotics engineers regularly encounter (control messages, static/dynamic coordinate transforms, location data, sensor data, etc). 

OK, the next main benefit - of most relevance to the PhD - is that the traits system will have significant affordances for ease-of-securing ros networks. See, if every software package has to implement a trait in order to be useful, we now have a formal language about the domain specific purpose of every component, and thus we can begin to reason _generically_ about the security implications. Through this, we can then begin to _automate_ security enclaves, following principle of least priviledge. Further, we can create something of a security QoS using the trait system: does it implement the trait _personal data_ ?; what about the traits _high bandwidth_ and _performance critical_? By organising software components by functionality and making them adhere to 'compile time' interfaces, we can glean useful information by which to make decisions about security at the system level, rather than offloading it to the users.

Finally, by enforcing a formal set of constraints the packages need to adhere to in order to be practically useful, we automatically usher in a sort of _meritocracy_ among developers of software components: the software packages who best align their supported interfaces with the trait system are going to find themselves to be more useful in a wider variety of use cases, and therefore are going to be more popular than those which have not thought very carefully about generalising their behaviour. A useful analogy for this is something like C++'s Standard Template Library (STL): a large collection of constructs which, taken as a whole, provide optimal generalised functionality. 
